/**
 * Created by Cherry on 2016/10/23.
 */
'use strict';

/*dependencies*/
var async = require('async');
var fs = require('fs');
var lineReader = require('line-reader');
var writeLine = require('lei-stream').writeLine;
var levelup = require('level');

/*parameter setup*/
var defaultInput = './default-input';
var defaultOutput = './default-output';
var inputDb;
var outputDb;
var totalSize = 0;
var sortFolder = './_sort';
var sortFileSize = 10000;
var sortFilePaths = [];
function convertToString(number,formatLength){
    var result=''+number;
    var initLength=result.length;
    if(initLength<10){
        if(!formatLength){
            formatLength=10;
        }
        for(var i=initLength;i<formatLength;i++){
            result='0'+result;
        }
    }
    return result;
}
var operator = function (a, b) {
    return a - b;
};

//===================================
var memoryUsage={
    rss:        0,
    heapTotal:  0,
    heapUsed:   0
};
function logMemoryUsage() {
    function convert(v) {
        return (v / 1024 / 1024).toFixed(2);
    }
    var info = process.memoryUsage();
    var rss = convert(info.rss);
    var heapTotal = convert(info.heapTotal);
    var heapUsed = convert(info.heapUsed);
    if(rss > memoryUsage.rss) {
        memoryUsage.rss = rss;
    }
    if(heapTotal > memoryUsage.heapTotal) {
        memoryUsage.heapTotal = heapTotal;
    }
    if(heapUsed > memoryUsage.heapUsed) {
        memoryUsage.heapUsed = heapUsed;
    }
}
//===================================

/*step1: split and sort data into ordered little files.*/
function splitData(callback) {
    var child = [];
    var start = 0, end = sortFileSize - 1;
    function loopSplit(){
        child.splice(0);
        inputDb.createReadStream({
                start: convertToString(start),
                end:   convertToString(end),
                keys:  false
            })
            .on('data', function (data) {
                if(data) {
                    totalSize++;
                    child.push(JSON.parse(data));
                }
            })
            .on('error', function (err) {
                console.log('Oh my!', err);
            })
            .on('close', function () {
            })
            .on('end', function () {
                start = end + 1;
                end += sortFileSize;
                if (child.length == sortFileSize) {
                    sortAndSave(child, loopSplit);
                }
                else if (child.length > 0) {
                    sortAndSave(child, callback);
                }
                else {
                    callback();
                }
            });
    }
    loopSplit();

}
var sortFileIndex = 1;
function sortAndSave(child, callback) {
    var filePath = sortFolder + '/' + sortFileIndex + '.txt';
    var outputStream = writeLine(filePath,
        {
            cacheLines: 10000
        });
    child.sort(function (a, b) {
        return operator(a, b);
    });
    child.forEach(function (data) {
        outputStream.write(JSON.stringify(data), function () {
        });
    });
    child.splice(0);
    sortFileIndex++;
    outputStream.end(function () {
        sortFilePaths.push(filePath);
        callback();
    });
}

/*step2: merge little files into one.*/
function mergeData(callback) {
    var openSortFiles = [];
    sortFilePaths.forEach(function (filePath) {
        openSortFiles.push(function (callback) {
            lineReader.open(filePath, function (err, reader) {
                if (err) {
                    callback(false, reader);
                }
                else {
                    callback(null, reader);
                }
            });
        });
    });
    async.series(openSortFiles, function (err, result) {
        if (err) throw err;
        var sortFileReaders = result;
        var readSortFiles = [];
        sortFileReaders.forEach(function (reader, index) {
            readSortFiles.push(function (callback) {
                reader.nextLine(function (err, data) {
                    if (err) {
                        callback(false, null);
                    }
                    else {
                        callback(null, {min: JSON.parse(data), index: index});
                    }
                });
            });
        });
        async.series(readSortFiles, function (err, result) {
            if (err) throw err;
            var minsInSortFile = result;
            var key = 0;

            function mergeLoop() {
                if (minsInSortFile.length < 1) {
                    callback();
                    return;
                }
                minsInSortFile.sort(function (a, b) {
                    return operator(a.min, b.min);
                });
                var minInAllData = minsInSortFile[0];
                outputDb.put(convertToString(key), JSON.stringify(minInAllData.min), function(err){
                    key++;
                    minsInSortFile.shift();
                    var targetReader = sortFileReaders[minInAllData.index];
                    if (!targetReader.hasNextLine()) {
                        targetReader.close(function (err) {
                            if (err) throw  err;
                            mergeLoop();
                        });
                    }
                    else {
                        targetReader.nextLine(function (err, data) {
                            setImmediate(function () {
                                if (err) throw  err;
                                minsInSortFile.push({min: JSON.parse(data), index: minInAllData.index});
                                mergeLoop();
                            });

                        });
                    }
                });
            }
            mergeLoop();

        })
    });
}


/*
 param1 input:    the path of file with data
 param2 oper:     comparing function
 param3 callback: callback function, it has output file path as parameter
 */
function externalSort(input, output, oper, callback) {
    /*create output folder*/
    fs.exists(sortFolder, function (exists) {
        if (!exists) {
            fs.mkdir(sortFolder, function () {
            });
        }
    });
    if (input) {
        inputDb = input;
    }
    else {
        inputDb = levelup(defaultInput);
    }
    if (output) {
        outputDb = output;
    }
    else {
        outputDb = levelup(defaultOutput);
    }
    if (oper) {
        operator = oper;
    }

    async.series([splitData, mergeData], function (err, result) {
        callback(totalSize);
    });
}

module.exports.externalSort = externalSort;